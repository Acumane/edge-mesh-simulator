from typing import * # type: ignore
import numpy as num
from nptyping import NDArray
from numpy.random import choice as choose
from random import randrange as randRange, random
from collections import deque
from math import sqrt
from rich import print

"""
Generates factory representation w/ features in 2D using the regions generated by proc.py

GRID is a 2D grid of "Chunks," which are 1x1xz slices of the scene. 
Each chunk is assigned a numerical value representing the type of element in the scene 
(documented rep.py KINDS). 

interfaced through:   def features(width, height, root, FREQ) -> Grid
where root is the AQT tree root and FREQ is feature frequencies
"""

FREQ = {0: 0, 1: 50, 2: 40, 3: 10}

def _normFreq(FREQ):
    ele = list(FREQ.keys()); prob = list(FREQ.values())
    val = sum(prob); ret = [v / val for v in prob]
    return ele, ret

def _pickFreq(FREQ):
    ele, prob = _normFreq(FREQ)
    return choose(ele, p=prob)

def _dist(p1, p2):
    y1, x1, y2, x2 = p1[0], p1[1], p2[0], p2[1]
    return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)

def _inBounds(bounds, vis, row, col):
    return (bounds[0] <= row < bounds[1] 
            and bounds[2] <= col < bounds[3] 
            and (row, col) not in vis)

def _runBFS(bounds, start, target, weight):
    ret = [start]; queue = deque([start])
    vis = set(); vis.add(start)
    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    while queue and len(ret) < target:
        cur = queue.popleft()
        if cur != start and random() < (weight / _dist(cur, start)): ret.append(cur)
        if len(ret) >= target: break
        for r, c in dirs:
            new_row, new_col = cur[0] + r, cur[1] + c
            if _inBounds(bounds,vis,new_row,new_col):
                queue.append((new_row, new_col))
                vis.add((new_row, new_col))
    return ret, vis

# chooses distribution of "close" nodes from start as a pile
def _weightedBFS(start, bounds, target, weight=1.0):
    result, visited = _runBFS(bounds, start, target, weight)
    while len(result) < target:
        for node in visited:
            if node != start and random() < (weight / _dist(node, start)):
                result.append(node)
    return result

def _placeChunk(grid, chunks, code):
    for chunk in chunks: grid[chunk[0], chunk[1]] = code

# finds placement max_dist
def _peekRegion(grid, dim, start, ori):
    y, x = start; y_max, x_max = dim; ret = 0
    inp =  [y,y_max,x] if ori else [x,x_max,y]
    for i in range(inp[0], inp[1]):
        if ori and grid[i, inp[2]] == 0 \
        or not ori and grid[inp[2], i] == 0: ret += 1
        else: break
    return ret

def _placeShelf(grid, inp, options, ori):    # noqa: PLR0912, C901
    spacing, gap, extra, p = options
    min_dist, min_gap = 3, 2; flag = extra
    y, x, dim = inp; i = x if ori else y
    while i < dim[ori]:
        rng = (y,i) if ori else (i,x)
        cur = _peekRegion(grid, dim, rng, ori)
        bnd = [y,y+cur,i] if ori else [x,x+cur,i]
        if cur > min_dist: 
            if ori: grid[bnd[0]:bnd[1], bnd[2]] = 1 
            else: grid[bnd[2],   bnd[0]:bnd[1]] = 1
        for loc in range(bnd[0] + gap, bnd[1], gap):
            if ori:
                if random() < p: grid[loc - gap : loc + 1, i] = 0
                elif y + cur - loc > min_gap: grid[loc, i] = 0
            else:    # noqa: PLR5501
                if random() < p: grid[i, loc - gap : loc + 1] = 0
                elif x + cur - loc > min_gap: grid[i, loc] = 0
        if extra and flag: i += 1; flag = False 
        else: i += spacing; flag = extra

def _shelves(grid, dim, start):
    y, x, y_max, x_max = start[0], start[1], dim[0], dim[1]
    spacing = choose([2, 3, 4]); gap = choose([5, 6, 7])
    extra_w = choose([0, 1], p=[0.75, 0.25])
    spacing += extra_w
    ori = 1 if min(y_max - y, x_max - x) == y_max - y else 0
    _placeShelf(grid, (start[0],start[1],dim), (spacing, gap, extra_w, 0.075), ori)

def _pile(grid, dim, start, num):
    y, x, y_max, x_max, p = start[0], start[1], dim[0], dim[1], 0.45
    for i in range(3):
        if i > 0 and random() >= p: continue
        y_range, x_range = randRange(y, y_max), randRange(x, x_max)
        bounds = [y, y_max - 1, x, x_max - 1]
        target = 20
        vals = _weightedBFS((y_range, x_range), bounds, target, weight=1.25)
        _placeChunk(grid, vals, num)
    _shelves(grid, dim, start)

def _pillars(grid, start, end):
    y_start, x_start, y_end, x_end = start[0], start[1], end[0], end[1]
    grid[y_start, x_start] = 3 # top-left corner
    grid[y_start, x_end - 1] = 3 # top-right corner
    grid[y_end - 1, x_start] = 3 # bottom-left corner
    grid[y_end - 1, x_end - 1] = 3 # bottom-right corner

type Grid[T] = NDArray[(int, int), T] # type: ignore

def features(width, height, root, FREQ) -> Grid:
    grid: Grid = num.zeros((height, width), dtype=int)

    def populate(node, num):
        y, x = node.y, node.x
        dim = (y + node.height, x + node.width)
        match num:
            case 1: _shelves(grid, dim, (y, x))
            case 2: _pile(grid, dim, (y, x), num)
            case 3: 
                grid[y : dim[0], x : dim[1]] = num
            case _:
                raise ValueError(f"Invalid feature: {num}")

        _pillars(grid, (y, x), dim)

    def fillRegions(node):
        if node.isLeaf():
            populate(node, _pickFreq(FREQ))
        else:
            for c in node.children: fillRegions(c)

    fillRegions(root)
    return grid